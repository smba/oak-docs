\documentclass[sigconf]{acmart}

% just in case
\usepackage{etex}

% does not seem to work with sigconf template
%\usepackage{cite}



\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{blindtext}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{listings,multicol}
\usepackage{lipsum}

\usepackage{enumerate}
\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{ucs}
\usepackage{framed}

\setlength\parindent{0pt}

\renewcommand{\sf}[1]{\textsf{#1}}
\renewcommand{\tt}[1]{\texttt{#1}}

\usepackage[zerostyle=d]{newtxtt}
%\renewcommand*\familydefault{\ttfamily} %% Only if the base font of the document is to be typewriter style
\usepackage[T1]{fontenc}

%\usepackage[labelfont=bf]{caption}

\definecolor{lightgrey}{HTML}{FFFFFF}

\hypersetup{
    colorlinks,
    linkcolor={red!65!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\usepackage{listings}  

\lstset{
	language=PHP,
	extendedchars = \true,
	basicstyle=\ttfamily\footnotesize,
	basewidth={0.5em,0.4em}, % for other columns settings
	commentstyle = \color{gray},
	columns=fullflexible,
	numbers=left,
	numberstyle=\tiny,
	frame=tb,
	showstringspaces=false,
	xleftmargin=2em,
	framexleftmargin=1.5em,
	backgroundcolor=\color{lightgrey},
	inputencoding = utf8x,
    keepspaces = true,
    keywordstyle = \bfseries
}

%\newcommand{\dollar}{\mbox{\textdollar}}


\newcommand*{\origrightarrow}{}
\let\oldarrow\textrightarrow
\renewcommand*{\textrightarrow}{\fontfamily{cmr}\selectfont\origrightarrow}

% ARIAL
%\usepackage{helvet}
%\renewcommand{\familydefault}{\sfdefault}


% TIMES
%\usepackage{mathptmx}% http://ctan.org/pkg/mathptmx

\usepackage{pgfplots, pgfplotstable}

\usepackage{xcolor}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[ISSTA'17]{ACM Woodstock conference}{July 2017}{Santa Barbara,
California, USA}
\acmYear{1997}
\copyrightyear{2016}

\acmPrice{15.00}


\begin{document}
\title{Does It Scale? Static Output Approximation of PHP Web Applications Using
Symbolic Execution}
\titlenote{Produces the permission block, and copyright information}
%\subtitle{Extended Abstract}
%\subtitlenote{The full version of the author's guide is available as  \texttt{acmart.pdf} document}


\author{Stefan Mühlbauer}
\affiliation{%
  \institution{Technische Universität Braunschweig}
  %\streetaddress{P.O. Box 1212}
  %\city{Braunschweig} 
  %\state{Germany} 
  %\postcode{43017-6221}
}
%\email{s.muehlbauer@tu-bs.de}

\author{Christian Kästner}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{Carnegie Mellon University}
  %\streetaddress{5000 Forbes Avenue}
  %\city{Pittsburgh} 
  %\state{PA} 
  %\postcode{15217}
}
%\email{s.muehlbauer@tu-bs.de}

\author{Tien N. Nguyen}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{University of Texas at Dallas}
  %\streetaddress{P.O. Box 1212}
  %\city{Braunschweig} 
  %\state{Germany} 
  %\postcode{43017-6221}
}
%\email{s.muehlbauer@tu-bs.de}


% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{S. Mühlbauer et al.}


\begin{abstract}
Dynamic web applications have become widely popular and are to
a large proportion based on the scripting language PHP. Output approximation of web
applications enables a range of additional tool support as well as possibilities
for vulnerability detection. Unfortunately, recent approximation approaches have
only been evaluated for smaller systems.

This paper presents an experience report about the scalability of output
approximation using symbolic execution of state-of-the-art PHP web
applications. For a symbolic execution engine extended with support for
object-oriented programming and arrays, we identified language features and
corresponding programming patterns that impede symbolic execution and limit the
scalability of this approach. Our findings include: (1) Dynamic features such as
functions and includes are prone to fail for certain programming patterns. (2)
Expressions containing elements from I/O, databases or files can heavily impede
symbolic execution. Our findings provide useful guidelines to design new
tools and also to improve the development process of statically analyzable web
applications.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% We no longer use \terms command
%\terms{Theory}

\keywords{ACM proceedings, \LaTeX, text tagging}

\maketitle

\section{Introduction}
With the emerging world wide web, dynamic web applications have become
widely popular. Various different implementation techniques have emerged,
ranging from technologies for programming languages (JSP, ASP .NET) and web
application frameworks for  script languages (Ruby On Rails, Django) to
languages tailored specifically to the domain of web applications. PHP
cite{phpNET} is a programming language focused on server-side application
development. As of 2012, it was used by 78.8 percent of the ten million most popular websites (according
to Alexa popularity ranking) \cite{alexaPHP}, ranking 7th on the TIOBE
programming community index \cite{tiobePHP}, and was the ranked as the 6th
most popular language on GitHub \cite{githubPHP}.

One common property of all technologies for dynamic web applications is
\emph{staged computation}: A dynamic web application as a whole
consists of both static code, such as scripts, and dynamically generated code,
such as client page output. The latter code, although assembled at
runtime, may contain client-side parts of the web application, such as
JavaScript. So, to study dynamic web applications in its entirety, we need to
consider both static as well as dynamic aspects of systems.

\emph{Symbolic execution} is a static analysis technique between program testing
and program proving. For a program, symbolic values are
used instead of concrete inputs \cite{Darringer1978,King1976}. The underlying
concept is to map program input to program output: Symbolic values are used and
propagated throughout the symbolic execution and keep dependencies for program
output traceable. This analysis technique helps unfold the \emph{staged} nature
of dynamic web applications. Since every feasible path can be executed the
symbolic output contains both invariant output as well as output variants that
depend on program input.

Knowledge about different output output variants is leveraged by a number of
analyses for the domain of web applications. Previous work presented tools
for detecting and locating HTML validation errors
\cite{Nguyen:2011:AFH:2190078.2190142}, computing program slices across
server-side and client-page code \cite{Nguyen:2015:CPS:2786805.2786872}, or
easing development and maintenance by extending IDE support for web applications
with code navigation
\cite{Nguyen:2015:VIS:2819009.2819140,Nguyen:2014:BCG:2635868.2635928}.

Despite the various use cases for analyses based on an approximated output
model, static output approximation for PHP web applications using symbolic
execution has so far only been evaluated for small systems that are not
maintained anymore. The tools presented by previous work
\cite{Nguyen:2015:VIS:2819009.2819140,Nguyen:2014:BCG:2635868.2635928,Nguyen:2015:CPS:2786805.2786872,Nguyen:2011:AFH:2190078.2190142}
though are only practical, if for a given system the symbolic execution engine
is scalable, i.e., will also approximate output accurately for larger and more
recent systems with acceptable time and space consumption.

To investigate the question, whether we can have a practical and scalable
symbolic executoin engine, we re-implemented the engine with the specifications
of the previous symbolic execution semantics \cite{Nguyen:2014:BCG:2635868.2635928} for PHP and additional features, such
as object-oriented programming. We evaluate our
symbolic execution engine for large-scale and modern PHP systems.

During the introduction of new semantics, we addressed two  trade-offs between
accuracy of our e xecution and performance: For method calls with ambiguous
targets as well as concrete execution of loops the number of program states can
become infeasible. This may require additional engineering adjustments to tame
the state space explosion at cost of accuracy.

Based on out observations we identify conceptual limitations of symbolic
execution for PHP.  Dynamic features such as indirect function calls and
include expression require concrete information to be evaluated properly. Since
these expressions may be assembled at runtime and can contain symbolic
information, for many cases this restricts our engine from further execution.
Although some effort to statically approximate include expression can be spent,
it is often non-trivial since expressions can contain information coming from
various inputs including databases, user inputs or configuration files. We
empirically evaluate our observations for a corpus including large PHP systems that are still maintained.

Our key contribution in this paper include (1)  a new tool infrastructure to
statically approximate the client-page output for PHP web applications using
symbolic execution and (2) a report of out observations for state-of-the-art
web applications as well as an empirical evaluation of conceptual limitations
of symbolic executions for PHP web applications.

\section{State Of the Art}\label{sec:stateoftheart}
Symbolic execution is one of integral analysis techniques used by the tools
whose practicality we aim to evaluate. This section recaps the idea of symbolic
execution, the tools which make use of it, and both conceptual and
language-related limitations.

\subsection{Symbolic Execution}
Symbolic execution is a static analysis technique that was proposed by James C.
King in 1976 \cite{King1976}. Symbolic execution allows to explore all feasible
paths in a program. Based on normal program execution, the execution semantics
is extended to handle symbolic values, which are abstract, but fixed; an
execution becomes symbolic by introducing symbolic values as program inputs
instead of concrete values \cite{King1976,Darringer1978}. These symbolic values
are then propagated and used throughout the execution.

Execution starts with a plain path condition, usually a tautology. Whenever the
control-flow can be split into different branches, the corresponding path
conditions (guards for instance) are conjoined with the previous path condition
\cite{King1976}. Additionally, the conjoined path condition can be checked for
satisfiability to exclude infeasible paths. Consequently, for a given program
symbolic execution computes a mapping from (symbolic) input values to output values.

\subsection{Static Output Approximation for PHP} \label{sec:workflow}
Symbolic execution is an analysis technique not dedicated to a particular
programming language. For dynamic web applications, in our case for web
applications written in PHP, it can be used to approximate all possible client
page output. Before we present in detail existing tools that aim to ease
development and maintenance of PHP web applications, we illustrate how output
approximation using symbolic execution is used by starting with an example.

\begin{figure}[t]
	\centering
	\begin{subfigure}[center]{0.48\textwidth}%%[multicols=1]
\begin{lstlisting}
<form>
  <input type="text" name="name">
  <input type="submit" value="Submit">
</form>

<?php
function make_titles($arg, $n) {
  $is = shuffle(array(1,2,3));
  while ($n < $is[0]) {
    echo "<h1>" . $arg . "</h1><br />";
    $n = $n + 1;
  }
}
  
call_user_func("make_titles", "Headline", 4);

$greeting = "Hello " . $_POST['name'] .  "!";
if (!isset($_POST['name'])) {
  echo "No name entered!";
} else {
  echo $greeting;
}
?>
\end{lstlisting}
		\caption{Snippet of HTML and PHP server-side web application code.
		\label{fig:web_application}}
    \end{subfigure}

	\vspace{2mm}    
    
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[center]{0.48\textwidth}
\begin{lstlisting}[mathescape]
<form>
  <input type="text" name="name">
  <input type="submit" value="Submit">
</form>

// #repeat n < shuffle(is)
<h1>Headline</h1><br />
// #endrepeat

// #if !isset(name)
No name entered!
// #else
Entered $\alpha$!
// #endif

\end{lstlisting}
		\caption{
			Approximation client paege output of the server-side web application code in
			Figure \ref{fig:web_application}. Variability as well as repetition annotations
			are represented by preprocessor directives.
			\label{fig:output_example}
		}
    \end{subfigure}
    \vspace{2mm}
    \caption{
    	Illustration of static ouptut approximation using symbolic
    	execution
    	\label{fig:code_example}
    }
\end{figure}

Figure \ref{fig:code_example} shows two code listings. The snippet of server-side web
application code in Figure \ref{fig:web_application} contains both HTML and PHP. First, the
function \texttt{make\_titles} defined in lines 7 – 13 prints the string
\texttt{\$arg} passed as an argument between zero and an arbitrary number of
times. Second, the function is indirectly called using the built-in function
\texttt{call\_user\_func} in line 15 with the string \texttt{Headline} and
\texttt{4} as arguments.  Finally, the input from the form in lines 1 – 4 is
used: The variable \texttt{\$greeting} consists of three concatenated strings,
\texttt{Hello} the value of input field \texttt{name}, and an exclamation mark.
For this server-side code snippet there are two possible client page output
variants: If the input field \texttt{name} is empty at runtime, line 19 is
executed and \texttt{No name entered!} is printed, or, if a name was entered,
line 21 is executed and the greeting constructed in line 17 is printed.



%C. Introduction to symbolic execution of PHP code
The following symbolic execution semantics for PHP features  based on \cite{Nguyen:2014:BCG:2635868.2635928}
illustrate the necessary modifications made to handle the extent of ambiguity
that comes with handling symbolic values. In addition to normal output, the
output approximation contains preprocessor directives to express
repeatable output as well as output variants. All approximated client page
output corresponding to Figure \ref{fig:web_application} consisting of two different variants
is illustrated in Figure \ref{fig:output_example}.
First, loops in the previous execution semantics are only executed once instead
of an arbitrary number of times. Since a loop condition can contain symbolic
values, it might not be feasible to determine when a loop terminates. Hence,
any output constructed during the single loop iteration is highlighted
(\texttt{repeat \ldots  endrepeat}) to possibly be repeated an arbitrary number
of times. The output in line 7 is marked to be repeated an arbitrary number of times, as the number
of loop iterations cannot be determined statically. Second, a similar procedure
applies to recursive functions. Once called, a recursive function is  also only
executed to recursion depth one per call, and any subsequent invocation of that
function returns a symbolic value. This, again, is due to the difficulty to
determine the exact recursion depth similar to the number of loop iterations.
Third, since the symbolic execution engine applies a static analysis, any form
of user interaction providing input data as well as any form of input referred
to from the deployment context of the web application, i.e. configuration files
or databases, is substituted by a symbolic value. The context variable
\texttt{\$\_POST} represents input submitted to the server and, hence, is
symbolic as every program input is per definition substituted by symbolic values. Finally, the
output in lines 11 and 13 respectively are marked as alternatives
(\texttt{if \ldots else \ldots endif}), as symbolic execution of lines 18 – 22
in Figure \ref{fig:web_application} will explore both different branches.

\subsection{Existing Tool Support for PHP}\label{sec:existing_tools}
All tools proposed so far leverage a representation of all possible HTML client
page output. Since any variant can be analyzed in particular, this enables tool
support addressing the web application as a whole in spite of its staged
nature, where parts of the web application (client-side output) are generated
dynamically.

Based on the approximated output representation subsequent analyses can be
conducted, which have been implemented in the following tools:
\begin{itemize}
	\item {\emph{PhpSync}: Using all variants of  HTML client page output, every
	single one can be statically checked for Markup Validity, i.e., if the web page
	conforms to syntactical specifications for HTML and other client-side
	languages. After validation errors are detected, auto-fixes are provided.
	Otherwise, the validation error can be traced back to source code responsible
	for the defect, which then can be refactored manually
	\cite{Nguyen:2011:AFH:2190078.2190142}. }

	\item \emph{WebSlice}: Program slices enable to extract and understand the
	impact of changes in an application. To consider all of a dynamic web
	application for program slices, client page output needs to be taken into
	account. WebSlice combines PHP data-flow information with an output
	approximation to enable program slices across different languages
	\cite{Nguyen:2015:CPS:2786805.2786872}.

	\item \emph{Varis}: Editor services such as “jump to declaration” are
	nontrivial for dynamic web applications due to their staged nature. Varis
	provides editor services across stages for client-side code: Starting with an
	ouput approximation a callgraph with conditional edges is constructed, which
	allows navigation in client-site code (HTML, JS and CSS) although it is
	embedded in server-side code
	\cite{Nguyen:2015:VIS:2819009.2819140,Nguyen:2014:BCG:2635868.2635928}.
\end{itemize}

\subsection{Assumptions And Limitations}\label{sec:limitations}
In addition to the limitations introduced by  symbolic execution, such as
symbolic inputs and one-time loop execution, the symbolic execution described
in \cite{Nguyen:2014:BCG:2635868.2635928} does not support advanced language
features, including object-oriented programming. Moreover, the range of
standard library functions supported are mostly string operations, yet PHP
provides a large collection of functions for array operations.
All three tools described in Section \ref{sec:existing_tools} though have only
been applied to systems that are small and not maintained any more. Despite the
functional benefits these tools provide to developers, their practicality for
large and modern systems with respect to advanced language support has not been
evaluated.

\section{Scalable Output Approximation}%
The main objective of this experience report is to investigate whether we can
have built practical tools that are on output approximations like the tools in
Section \ref{sec:existing_tools}. In particular, we want to find out whether
symbolic execution as the underlying technique for static output approximation
is scalable, i.e., it computes an accurate approximation for large and modern
PHP systems with reasonable time and space consumption.

Also, we are interested in the limitations of scalable symbolic execution for
PHP web applications. Limitations may either be conceptional, where symbolic
execution of PHP code, in contrast to concrete execution, is inaccurate: For
example an include expression evaluated to a symbolic value simply provides to
little information to include a script. Or, in spite of infeasible effort
required, limitations could allow an accurate symbolic execution. For example,
exhaustively exploring all feasible paths in an application may result in an
infeasible number of program states to store; nevertheless, this so called
state explosion problem may be addressed with additional engineering.

\subsection{Towards Scalable Output Approximation?}
As our goal is to have practical tools support, we approach this question by
re-implementing the symbolic execution semantics described in
\cite{Nguyen:2014:BCG:2635868.2635928} and extending it with support for
additional language features. We choose to aim to support symbolic execution
for a real-world example system of reasonable size that incorporates the
missing language features described in Section \ref{sec:limitations} and is
still developed and maintained: \textsf{WordPress} is a popular open-source
Content Management System (CMS) with around 300k lines that provides a vivid
plug-in environment and is maintained by a large community.
For our implementation of a symbolic execution engine for PHP,
\textsf{Oak}\footnote{The implementation can be found
at \url{github.com/smba/oak}.}, we have chosen a test-driven approach with
continuous integration using regression tests based on \textsf{WordPress} and \textsf{SchoolMate} (see Section \ref{sec:experiment_setup}). Oak incorporates the existing execution semantics
of \cite{Nguyen:2014:BCG:2635868.2635928} and extends it with support for
object-oriented orientation (class definition, class instantiation and method
invocation) as well as PHP array operations. A list of the functions provided
by the PHP standard library can be found at \cite{PHP}.
Throughout the implementation we did not achieve high code coverage for
WordPress, which was the main motivation to further investigate limitations in
the wild.

\subsection{Experience Report}
We identified a number of trade-offs between accuracy and performance that may
cause the approximation to be impractical, yet possible. Also, we identified
limitations impeding symbolic execution conceptually. For certain language
features, concrete information rather than symbolic values may be required to
actually be executed properly as this defective execution can impact subsequent
parts of the program which may become inaccessible and may be missed.

\subsubsection{Symbolic vs Concrete Execution}
Throughout the implementation, we basically followed the symbolic execution
semantics described in \cite{Nguyen:2014:BCG:2635868.2635928}. Nevertheless, for additional language features as
well as standard library functions we experienced it to be beneficial to the
approximation to execute them as concretely as possible.
For instance, \sf{WordPress} uses a text filter mechanism, where different
filter functions are applied sequentially to a string literal. All filters can
be linked to a hook using  associative arrays so that when the hook is
triggered, all filters linked to it are applied. As described in Section \ref{}
we execute loops, in particular while loops, only once due to an possibly
indeterminable number of iterations. PHP yet offers more loop constructs: the
do-while loop and the foreach loop. While for the do-while loop as well as for
the while loop the number of iterations is possibly indeterminable, the foreach
loop iterates over all items of a given array whose number of items is known at
runtime. For \sf{WordPress}, we are able to achieve a more accurate
approximation and higher code coverage results by concretely executing foreach
loops as more server-side code (filter functions in our case) are accessed and
executed. In turn, exhaustively executing foreach loops and filter functions
concretely is a trade-off between accuracy and performance, as single hook can
be called for different contexts as we are exploring multiple execution paths.

An additional aspect on the boundary of concrete and symbolic execution, or
effort and accuracy respectively, is the extent to which program inputs are
assumed to be symbolic. As shown in Section \ref{} introducing symbolic values
can be problematic if they are propagated to language features requiring
concrete information, such as include expressions or indirect function calls.
We manually scaled the number of sources of symbolic inputs by providing static
dummy inputs such as a concrete form input, file name or configuration entry.
For specific cases, where concrete information is inevitably required, we can
achieve higher code coverage and a more accurate approximation, as more code
becomes accessible. Nevertheless, while detecting dynamic features can be
automated, it requires manual inspection and understanding of the web
application to provide appropriate dummy input data. Again, this is a trade-off
between the effort to provide input data and accuracy of the approximation and
code coverage respectively.

\subsubsection{Multi-Target Method Calls}
The first non-conceptual problem we encountered, in particular for
\sf{WordPress} is related to object-oriented programming. While exploring
different execution paths when the control flow is split, a variable can have
different values depending on the path condition under which a value has been
assigned to it (see the code example in Figure \ref{fig:output_example}). Similar, a variable
can point to different objects depending on the path condition as the snippet in
Figure \ref{fig:multi_target} illustrates. The variable \tt{\$person} can either
point to object \tt{Alice} or \tt{Bob}. In addition, for any method invocated on
that variable, the actual target is ambiguous as there are two, depending on the
path condition. In order to have a sound symbolic execution, both method calls
need to be executed. Nevertheless, the number of contexts for a method can grow
rapidly, and easily become infeasible to execute.

We implemented several heuristic approaches to tame this state space explosion
for multi-target method calls, including executing a method only for a subset or
just a single object. This trade-off between accuracy and soundness
of the symbolic execution and performance time required.

\subsubsection{Dynamic Language Features}
Conceptually, symbolic execution failed for two types of language features. As
stated in Section \ref{sec:workflow}, dynamic web applications are staged and client page
output is computed at runtime. Symbolic execution hand has shown to be a useful
technique to approximate dynamically generated output, it is challenged by
language features that require concrete information rather than symbolic
information at runtime. In particular, this applies to language features that
provide access to reusable code of the web application: include expressions and
function calls.

First, include expressions in PHP usually require a string value representing
the path to the script file or template to include. If this string value is
statically provided by a string literal or can be constructed unambiguously, the
symbolic execution engine was able to resolve the include expression and include
the desired file. However, it is also common to assemble include expressions not
only static string literals, but from several sources including user input
information, database query results or configuration files. Figure
\ref{fig:dynamic_includes} shows a small example of a dynamic include containing
information retrieved from a database. Since any input for a symbolically
executed application is symbolic this information leads to include expressions
containing symbolic values. Also, configuration files represent only one
particular configuration or even just default values or placeholders. Hence, 
symbolic execuion is prone to fail for dynamic includes if symbolic information
is contained.

Second, function calls can either be direct by statically providing the name of
the function (or method), or indirect. Indirect function calls in PHP are
enabled by using built-in functions like \tt{call\_user\_func},
\tt{call\_user\_func\_array} or simply passing a string value with a direct
function call to the \tt{eval} function. The first two functions take as
arguments the name of the function two call, and all arguments to that functions either as additional arguments or
array respectively. The eval function evaluates a given PHP expression passed
as a string literal.
Again, we encountered similar issues to dynamic include expressions with
indirect function call mechanisms. The example in Figure
\ref{fig:indirect_calls} illustrates two functions \tt{header\_serif} and
\tt{header\_sserif} which both print a HTML headline. Depending on whether the
value of the variable \tt{\$style} retrieved from a database is \tt{serif} or
\tt{sserif}, a different function is called. Given that the function name is 
concrete at runtime, the desired function can be called. Otherwise, if the
function name is assembled at runtime and contains symbolic values, no function
can be called as the name is ambiguous or unknown. For this example, symbolic
execution is not able to determine which function to call indirectly.

% code examples for 3.3 experience report
\begin{figure}[t]
	\begin{subfigure}[b]{0.48\textwidth}
	
\begin{lstlisting}
<?php
class Person {
   function __construct__($name) {
      $this->name = $name;
   }
   function greet($greeting) {
      echo $greeting . $this->name;
   }
}

if (...) {
   $person = new Person("Alice");
} else {
   $person = new Person("Bob");
}
$person->greet("Good Morning, ");
\end{lstlisting}
	\caption{
		Dynamic dispatch: Multiple targets for method calls
		\label{fig:multi_target}
	}
	\end{subfigure}
	\vspace{2mm}
	\hfill
	\begin{subfigure}[b]{0.48\textwidth}

\begin{lstlisting}
<?php
define("ROOT", getcwd());
define("TEMPLATES", ROOT . "templates/")

$template = mysql_result(...);

require_once TEMPLATE . $template;
\end{lstlisting}
	\caption{
		Dynamic Include Resolution
		\label{fig:dynamic_includes}
	}
	\end{subfigure}
	\vspace{2mm}
	\hfill
	\begin{subfigure}[b]{0.48\textwidth}

\begin{lstlisting}
<?php
function header_serif($title) {
   $style = "font-family: serif;";
   echo "<h1 style = '$style'>$title</h1>";
}
function header_sserif($title) {
   $style = "font-family: sans-serif;";
   echo "<h1 style = '$style'>$title</h1>";
}

$font_style = mysql_result(...);
call_user_func('header_' . $font_style, 'Title');
\end{lstlisting}
	\caption{
		Function calls by indirect invocation mechanisms
		\label{fig:indirect_calls}
	}
	
	\end{subfigure}
	\caption{
		Code Examples of defective code features
		\label{fig:defective_code_features}
	}
\end{figure}

\subsubsection{Interpreter Customization}
We have approached issues we encountered in different ways, including
multiple-target method calls and foreach loops, as these represent a trade-off
between accuracy of execution and performance.
For method calls having ambiguous targets, we implemented different modes of
execution, ranging from a complete mode where a method is executed for all
possible targets to abstract modes with either a subset of targets or only a
single target. In the latter cases where targets are discarded, we assumed
symbolic values as method return values. Our symbolic interpreter can be
customized to work in the desired mode to scale accuracy or performance.
Nevertheless, for \sf{WordPress} these variations did not have significant
impact on the output approximation as symbolic execution was rather impeded by
dynamic features.
Also, for foreach loops we are able to toggle between a single iteration mode
and a complete iteration mode. Although we were able to increase code coverage
by accessing more code, it did not significantly increase our output
approximation.
Note that these variants have only been tested for \sf{WordPress} to better
understand possible trade-offs or simply achieve any output approximation in a
reasonable period of time. We believe based on our experience dynamic features
to be the main conceptual limitation impeding code coverage as well as output
approximation quality. In the next Section we analyze in detail the impact of
dynamic features with concrete foreach loop execution and complete
multiple-target execution for method calls.


\section{Evaluation}
As already stated in the previous section, we encountered sevaral problems
during the development of the symbolic interpreter. Therefore this section
describes our methods to evaluate practicality of the output approximation, and
possible explanations.

\subsection{Measuring Approximation Success} \label{heuristic}
For the evaluation of our output approximation we require a ground truth output
model to compare our approximation against. Since output literals are embedded
in server-side code and scattered, it is nontrivial to determine whether a
string literal is part of the ouput or not. So, in the absence of ground truth
for the approximated output we are bound to choose a \emph{heuristic approach}
in order to measure the accuracy of our aproximation. We define a string
literal to be an \emph{output candidate} if there exists an execution path
reaching the string literal and evantually passing it to an output-generating
statement (e.g., \texttt{echo} or \texttt{print}).

We approximate output candidates as those string literals containing the
characters \texttt{<}, \texttt{>}, or both since we expect output to contain
HTML tags. We evaluated this heuristic manually with a sample of 400 string
literals randomly selected from the entire corpus.
We measured for our heuristic classifier a precision of 94 percent, and a
recall of 50 percent. This means that six percent of the string literals are
classified incorrectly as false positives. In turn, the classifier is highly
distinctive as 96 percent of the string literals are classified correctly. The
recall of 50 percent means that half of the string literals, which we manually 
classified as output, actually were responsive to the classifier. We attempted
to increase recall by looking for further distinctive properties to build a
classifier from, but could not do so without decreasing precision. In spite of
missing half of the output candidates, we decided to use a simple, yet
distinctive classifier.

\subsection{Experiment Setup} \label{sec:experiment_setup}
For the evaluation we symbolically executed a selection of PHP systems. We
selected a corpus of twelve PHP systems with regard to system size and recency
as the corpus of the case study for \cite{Nguyen:2014:BCG:2635868.2635928} only
contained small-scale systems that are not maintained any more. The full list
of PHP systems is shown in Table \ref{corpus}. Our selection of PHP systems
includes%
\begin{itemize}
	\item four small-scale systems that selected from the previously mentioned case
	study in order to compare our results with the previous symbolic execution
	engine \cite{Nguyen:2014:BCG:2635868.2635928},

	\item three recent large-scale systems selected from the case study corpus of
	\cite{Hills:2013:ESP:2483760.2483786}, and
	
	\item four small-scale systems selected from a list of recent Content
	Management Systems \cite{codegeekz}.
\end{itemize}

As for for the last two cases, we limited our selection since the parser we
used did not support all language features used. For the experimental evaluation we symbolically executed per system each script file or entry point (files with a \texttt{.php}, \texttt{.inc}, \texttt{.bit} or \texttt{.module} extension). All following measurements are cumulated per system for each entry point. 

\begin{table*}[t]
\centering 
	\begin{tabular}{lrp{4cm}rrrr}
	\toprule
	\textbf{System} & \textbf{Version} & \textbf{Classification} & \textbf{SLOC} &
	\textbf{\#files} & \textbf{\#OCs} & \textbf{\#includes}
	\\
	\midrule
	AddressBook & 8.2.5.2 &  & 51,907 & 239  & 1009 & 186\\
	SchoolMate & 1.5.4 &  & 8,118 & 65  & 853 & 88\\
	TimeClock & 1.04 &  & 20,800 & 63  & 7920 & 306\\
	WebChess & 1.0.0 &  & 5,219 & 28  & 470 & 56\\
	\midrule
	Drupal & 7.5.0 & CMS & 52,464 & 125  & 3569 & 749\\
	phpBB & 3.1.9 &  & 327,371 & 1,398  & 3606 & 206\\
	phpMyAdmin & 4.6.3 &  & 303,582 & 871  & 7103 & 571\\
	\midrule
	Anchor & 0.12.1 &  & 15,054 & 201 & 987 & 32\\
	Kirby & XXX & CMS & XXX & XXX  & 654 & 23\\
	Automad & XXX & CMS & XXX & XXX  & 655 & 8\\
	Monstra & XXX & CMS & XXX & XXX  & 1934 & 48\\
	Nibbleblog & XXX & CMS & XXX & XXX  & 1013 & 28\\
	\bottomrule
	\end{tabular}
	\caption{Corpus of twelve PHP systems. The file count includes files with a .php,
	.inc, .bit or .module extension.}
	\label{corpus}
\end{table*}


\subsection{Measuring Approximation Accuracy}
\label{HowAccurateIsOurApproximation} 
In Section \ref{heuristic} we introduced the definition of output candidates as
expected output. As a most accurate approximation contains all output
candidates, we define two metrics to measure accuracy of our approximation.

First, we measure how much of the expected output was actually processed by the
symbolic interpreter.  Once a line of code, a statement or expression
containing an output candidate is actually an element in an execution path, we
define this output candidate as reached. We define the metric \emph{reach
coverage} as the ratio of output candidates that are reached and the total
number of output candidates in the analyzed system. Although a reached output
candidate is processed by the symbolic interpreter, it does not guarantee we
will see that output candidate in the symbolic output. Second, we define the
metric \emph{output coverage} as the ratio of output candidates that are
contained in the output of the symbolic interpreter and the total number of
output candidates in the analyzed system.  For an imprecise approximation, we
may see loss of output candidate information resulting in a output coverage
lower than the reach coverage.

The coverage results are illustrated in Figure \ref{coverage}. We could
replicate high coverage results for the four small-scale systems with a reach
coverage and output coverage over 80 percent respectively. For the three
modern/large-scale systems we measured poor coverage with reach coverage
ranging from 5 to 30 percent and output coverage ranging from 4 to 20 percent.
We measured medium to high coverage for the more recent small-scale systems:
reach coverage ranging from 43 to 85 percent, output coverage ranging from 40
to 85 percent.

\subsection{Understanding Limitations}
As we have seen in Section \ref{HowAccurateIsOurApproximation} both measured
coverage metrics were poor for large-scale and small-scale/recent systems. To
understand what output candidates we missed and why, we further investigated
our approximation results and conducted three more measurements.

\subsubsection{What literals did we miss?}\label{WhatLiteralsDidWeMiss?}
Our initial approach to understand missed output candidates is to find out
whether their surrounding program code was not accessed/accessible, and if so,
why. Of special interest are those output candidates that are located in HTML
files (possibly with nested PHP), or located in a function definition. Plain
HTML files do not require any further execution (of course, unless PHP scripts
are embedded) and represent output candidates that just need to be included
properly to be part of the output. Aside, output candidates that are part of a
function definition are only missed if the corresponding function is never
called at runtime.

We started classifying missed output candidates by their string literal
context. As the classification statistics in Figure \ref{coverage} illustrate,
for almost all systems (except for \textsf{AddressBook} and \textsf{TimeClock})
not-reached output candidates had a function context. Note that
\textsf{SchoolMate} was excluded from the diagram since our analysis reached
all output candidates for that system.

\subsubsection{Inaccessible Dynamic Features}
\label{sec:inaccessible}
For both cases of context, either inclusion of a script file failed, or a
function call failed. If an HTML file is not part of the output, it also is
never reached, i.e., included. An include can fail due to various reasons, such
as an imprecise evaluation of the include expression returning a symbolic
value, or simply a missing file.

For a function to be never reached there are several scenarios: A function is
undefined at runtime if the corresponding script file is never included. In
turn, if the function is defined at runtime the function can either be dead
code if there is no call site for this function, or the function call failed.
In PHP there are several ways to call a function beside direct call sites. The
language offers indirect call mechanisms like callback-commands or an
evaluation function that parses and evaluates PHP source code as strings.

Given a symbolic value, indirect call mechanisms like callback-commands are
likely to fail since target function name and the symbolic value do not match.
This also applies for the evaluation of include expressions as concrete values
representing include targets can be included, but any include target containing
symbolic values is ambiguous.

\subsubsection{Why did includes fail?}
\label{WhyDidIncludesFail}
To better understand include expression evaluation, we use another metric to
approach accuracy from a different angle: We measure (1) the ratio of reached
include expressions and the total number of include expressions in a system
respectively (coverage of include expressions), and (2) the ratio of
successfully resolved include expressions and reached include expressions in a
system (resolution success rate). For a most accurate result all include
expressions are reached and resolved.

For include expressions we sampled failed attempts and manually evaluated the
cause of failure. We identified for (1) that all failed attempts were dynamic
include expressions, i.e., those which were resolved at runtime and were
assembled from fragments of environment-dependent information including
database retrievals, user input, or files. Consequently, the resolved include
expressions contained symbolic values which did not represent identifiable
script files.

Finally, we measured for include expressions the overall reach coverage and the
overall resolution success rate per system. As illustrated in Figure
\ref{fig:include_coverage_results}, except for the small-scale systems and two
recent small-scale systems we did not even really reach a great portion of
include expressions, although for most systems the resolution success rate was
over 80 percent. Nevertheless, one failed attempt to include a script file can
result in a cascade of missing more include expressions as the include target
script is not executed.

\subsubsection{Why did function calls fail?}
\label{WhyDidFunctionCallsFail}
Aside from failed or successful includes, this metric describes one scenario of
why functions containing not-reached output candidates are never called: The
trivial explanation would be that there are no direct calls of those functions,
yet PHP offers a number of ways to call a function indirectly, for instance
using built-in functions, or simply evaluating strings as PHP code using the
\texttt{eval} function.

Moreover we need to take into account that one missed function execution can
result in missing even more function calls (direct or indirect) and executions.
Thus, for functions containing not-reached output candidates we measure whether
they can be (1) only, (2) partially or (3) never accessed transitively from
functions that have no direct call sites. We refer to those functions (or
access points) having no direct call site as callback candidates since the only
way to reach them is through indirect mechanisms. Measuring how many
not-reached output candidates can be explained by functions that are callback
candidates helps to understand whether, and if so, indirect call mechanisms and
their usage may impact our analysis’ code coverage.

The callgraph snippets in Figure \ref{fig:callgraph} illustrate the idea of
detecting the functions’ access points: The nodes at the top depict callback
candidates, the nodes at the bottom with labels X, Y, and Z depict function
definitions containing not-reached output candidates. In Figure
\ref{fig:callgraph} function X can only be accessed through callback
candidates, as for Figure \ref{fig:callgraph} function Y can be partially
accessed by callback candidates, whereas function Z is never accessible through
callback candidates.

% Callback candidate description
\begin{figure}[t!]
	%\centering
	\includegraphics[scale=0.55]{images-paper/callgraph_cases}
    \caption{Callgraph analysis: The bottom nodes represent functions containing missed output candidates, the top nodes depict entry points to them.}
    \label{fig:callgraph} output candidates we measured how many of those functions were only, or partially accessibly through indirect calling mechanisms (see Section \ref{sec:inaccessible}). As Figure \ref{fig:output_candidate_explanation} illustrates, around 80 percent (except for \textsf{TimeClock}) all missed output candidates of each system were only accessible through callback candidates, i.e., functions that are only accessible through indirect calling mechanisms.
	
\end{figure}

Like for include expressions, we again sampled dead function cases and
identified the lack of direct call sites to those functions. As described in
Section \ref{sec:inaccessible}, functions despite having no direct call sites
were called through indirect call features. We identified dynamically assembled
expressions (function names) to be responsible for failed attempts of calling a
function indirectly as the resolved function name eventually contained symbolic
values. These expressions, as well as include expressions, contained
information dependent on the system environment.

For failed function calls to functions containing not-reached
	
	
	% RESULT DIAGRAMS
\begin{figure}[h!]
	\begin{subfigure}[center]{0.48\textwidth}
		\input{new_diagrams/not_reached}
		\caption{\label{coverage}}
	\end{subfigure}
	
	\begin{subfigure}[center]{0.48\textwidth}
		\input{new_diagrams/includes}
		\caption{
			Include coverage and accuracy.
			\label{fig:include_coverage_results}
		}
	\end{subfigure}
	
	
	% Callback candidate explanation
	\begin{subfigure}[center]{0.48\textwidth}
		\input{new_diagrams/callbacks}
		\caption{
			Distribution dead function output candidates that are par-
			tially or completely explained due to callback candidates.
			\label{fig:output_candidate_explanation}
		}
		
	\end{subfigure}
	\caption{Results}
\end{figure}

\section{Lessons Learned}
\textcolor{blue}{\Blindtext}


\section{Related Work}
\cite{Hills:2013:ESP:2483760.2483786}
\cite{wassermann2007sound,minamide2005static}
\textcolor{blue}{\blindtext\blindtext}

\newpage
%References
\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography} 

\end{document}
